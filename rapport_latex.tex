% =============================================================================
% RAPPORT TECHNIQUE - BIBLIO POCHE API
% =============================================================================

\documentclass[12pt,a4paper]{report}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{lmodern}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[hidelinks]{hyperref}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{enumitem}
\usepackage{float}
\usepackage{caption}
\usepackage{tocloft}

% Configuration de la page
\geometry{margin=2.5cm}

% Couleurs personnalisées
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{primaryblue}{RGB}{0,102,204}

% --- DÉFINITION DU LANGAGE JAVASCRIPT ---
% C'est ce bloc qui manquait et causait l'erreur "undefined language"
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break, const, let, async, await, export, default, import, from, class, extends, super, this},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={boolean, throw, implements, interface, package, private, protected, public, static},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{codegreen}\ttfamily,
  stringstyle=\color{codepurple}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

% Configuration des listings de code
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single,
    rulecolor=\color{black},
    literate={é}{{\'e}}1 {è}{{\`e}}1 {à}{{\`a}}1 {ç}{{\c{c}}}1 {ê}{{\^e}}1 {ù}{{\`u}}1 {ô}{{\^o}}1 {î}{{\^i}}1
}
\lstset{style=mystyle}

% Configuration des liens
\hypersetup{
    colorlinks=true,
    linkcolor=primaryblue,
    filecolor=magenta,
    urlcolor=cyan,
    pdftitle={Biblio Poche API - Rapport Technique},
    pdfauthor={},
}

% En-tête et pied de page
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\leftmark}
\fancyhead[R]{Biblio Poche API}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% =============================================================================
% DEBUT DU DOCUMENT
% =============================================================================

\begin{document}

% -----------------------------------------------------------------------------
% PAGE DE TITRE
% -----------------------------------------------------------------------------

\begin{titlepage}
    \centering
    \vspace*{2cm}

    {\Huge\bfseries Biblio Poche API\par}
    \vspace{0.5cm}
    {\Large Plateforme de Vente de Livres en Ligne\par}
    \vspace{2cm}

    {\Large\bfseries Rapport Technique\par}
    \vspace{1cm}

    {\large API REST \& GraphQL avec Node.js/Express\par}
    \vspace{2cm}

    {\Large\bfseries Réalisé par :\par}
    \vspace{0.5cm}
    {\large Nika ZARUBINA\par}
    {\large Sabrina SADDEDINE\par}

    \vfill

    {\large\today\par}
\end{titlepage}

% -----------------------------------------------------------------------------
% TABLE DES MATIERES
% -----------------------------------------------------------------------------

\tableofcontents
\newpage

% =============================================================================
% CHAPITRE 1 - INTRODUCTION
% =============================================================================

\chapter{Introduction}

\section{Présentation du Projet}

Biblio Poche est une API backend complète pour une plateforme de vente de livres en ligne. Le projet offre deux interfaces d'accès aux données : une API REST traditionnelle et une API GraphQL, permettant aux développeurs de choisir l'approche la plus adaptée à leurs besoins.

\section{Objectifs}

\begin{itemize}
    \item Fournir une API robuste et sécurisée pour la gestion d'une librairie en ligne.
    \item Implémenter les meilleures pratiques de sécurité (JWT, protection XSS, NoSQL Injection).
    \item Offrir une documentation complète et des tests de sécurité.
    \item Permettre une double interface REST et GraphQL.
\end{itemize}

\section{Technologies Utilisées}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Catégorie} & \textbf{Technologie} \\
\hline
Runtime & Node.js \\
Framework & Express.js \\
Base de données & MongoDB avec Mongoose \\
API GraphQL & Apollo Server Express \\
Authentification & JWT (JSON Web Tokens) \\
Sécurité & bcryptjs, xss, helmet \\
Documentation & Swagger/OpenAPI 3.0 \\
\hline
\end{tabular}
\caption{Stack technique du projet}
\end{table}

% =============================================================================
% CHAPITRE 2 - ARCHITECTURE
% =============================================================================

\chapter{Architecture du Projet}

\section{Structure des Dossiers}

\begin{lstlisting}[language=bash, caption={Structure du projet}]
biblio-poche/
|-- backend/
|   |-- graphql/          # Configuration GraphQL
|   |   |-- index.js      # Setup Apollo Server
|   |   |-- schema.js     # Types GraphQL
|   |   |-- resolvers.js  # Resolvers GraphQL
|   |-- middleware/       # Middlewares Express
|   |   |-- auth.js       # Authentification JWT
|   |   |-- admin.js      # Verification role admin
|   |-- models/           # Modeles Mongoose
|   |   |-- Book.js
|   |   |-- User.js
|   |   |-- Order.js
|   |   |-- Payment.js
|   |-- routes/           # Routes REST
|   |   |-- authRoutes.js
|   |   |-- bookRoutes.js
|   |   |-- orderRoutes.js
|   |   |-- paymentRoutes.js
|   |   |-- adminRoutes.js
|   |-- utils/            # Utilitaires
|   |   |-- sanitize.js   # Protection XSS
|   |   |-- helpers.js    # Fonctions partagees
|   |-- server.js         # Point d'entree
|-- frontend/             # Application React
|-- postman/              # Collections Postman
|-- security_tests/       # Tests de securite Python
\end{lstlisting}

\section{Modèles de Données}

\subsection{Modèle User}

\begin{lstlisting}[language=JavaScript, caption={Schema User}]
const userSchema = new mongoose.Schema({
    username: { type: String, required: true, unique: true },
    email: { type: String, required: true, unique: true },
    password: { type: String, required: true },
    role: { type: String, enum: ['user', 'admin'], default: 'user' }
}, { timestamps: true });
\end{lstlisting}

\subsection{Modèle Book}

\begin{lstlisting}[language=JavaScript, caption={Schema Book}]
const bookSchema = new mongoose.Schema({
    title: { type: String, required: true },
    author: { type: String, required: true },
    price: { type: Number, required: true },
    category: { type: String, required: true },
    description: { type: String },
    image: { type: String },
    stock: { type: Number, default: 10 },
    rating: { type: Number, default: 0 },
    numReviews: { type: Number, default: 0 },
    reviews: [reviewSchema]
}, { timestamps: true });
\end{lstlisting}

\subsection{Modèle Order}

\begin{lstlisting}[language=JavaScript, caption={Schema Order}]
const orderSchema = new mongoose.Schema({
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    orderItems: [{
        title: String,
        qty: Number,
        price: Number,
        product: { type: mongoose.Schema.Types.ObjectId, ref: 'Book' }
    }],
    shippingAddress: {
        address: String, city: String,
        postalCode: String, country: String
    },
    totalPrice: { type: Number, required: true },
    status: {
        type: String,
        enum: ['pending', 'confirmed', 'shipped', 'delivered', 'cancelled'],
        default: 'pending'
    }
}, { timestamps: true });
\end{lstlisting}

% =============================================================================
% CHAPITRE 3 - API REST
% =============================================================================

\chapter{API REST}

\section{Endpoints d'Authentification}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Méthode} & \textbf{Endpoint} & \textbf{Description} \\
\hline
POST & /api/auth/register & Inscription d'un utilisateur \\
POST & /api/auth/login & Connexion et obtention du token \\
\hline
\end{tabular}
\caption{Endpoints d'authentification}
\end{table}

\section{Endpoints des Livres}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Méthode} & \textbf{Endpoint} & \textbf{Description} & \textbf{Auth} \\
\hline
GET & /api/books & Liste des livres & Non \\
GET & /api/books/:id & Détails d'un livre & Non \\
POST & /api/books & Ajouter un livre & Admin \\
POST & /api/books/:id/reviews & Ajouter un avis & Oui \\
\hline
\end{tabular}
\caption{Endpoints des livres}
\end{table}

\section{Endpoints des Commandes}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Méthode} & \textbf{Endpoint} & \textbf{Description} \\
\hline
POST & /api/orders & Créer une commande \\
GET & /api/orders/myorders & Mes commandes \\
GET & /api/orders/:id & Détails d'une commande \\
PUT & /api/orders/:id & Modifier l'adresse \\
PUT & /api/orders/:id/cancel & Annuler une commande \\
\hline
\end{tabular}
\caption{Endpoints des commandes (authentification requise)}
\end{table}

\section{Endpoints Administration}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Méthode} & \textbf{Endpoint} & \textbf{Description} \\
\hline
GET & /api/admin/stats & Statistiques dashboard \\
GET & /api/admin/books & Liste des livres (pagination) \\
POST & /api/admin/books & Ajouter un livre \\
PUT & /api/admin/books/:id & Modifier un livre \\
DELETE & /api/admin/books/:id & Supprimer un livre \\
GET & /api/admin/orders & Liste des commandes \\
PUT & /api/admin/orders/:id & Modifier statut commande \\
GET & /api/admin/users & Liste des utilisateurs \\
PUT & /api/admin/users/:id/role & Modifier rôle utilisateur \\
\hline
\end{tabular}
\caption{Endpoints administration (rôle admin requis)}
\end{table}

% =============================================================================
% CHAPITRE 4 - API GRAPHQL
% =============================================================================

\chapter{API GraphQL}

\section{Configuration Apollo Server}

\begin{lstlisting}[language=JavaScript, caption={Configuration Apollo Server}]
const { ApolloServer } = require('apollo-server-express');

async function createApolloServer(app) {
    const server = new ApolloServer({
        typeDefs,
        resolvers,
        context: ({ req }) => {
            const token = req.headers.authorization || '';
            const user = getUser(token);
            return { user };
        }
    });

    await server.start();
    server.applyMiddleware({ app, path: '/graphql' });
    return server;
}
\end{lstlisting}

\section{Types GraphQL}

\begin{lstlisting}[language=JavaScript, caption={Définition des types}]
type Book {
    id: ID!
    title: String!
    author: String!
    price: Float!
    category: String!
    description: String
    image: String
    stock: Int!
    rating: Float
    numReviews: Int
    reviews: [Review]
}

type User {
    id: ID!
    username: String!
    email: String!
    role: String!
}

type AuthPayload {
    token: String!
    user: User!
}
\end{lstlisting}

\section{Queries et Mutations}

\begin{lstlisting}[language=JavaScript, caption={Queries GraphQL}]
type Query {
    # Livres
    books(category: String): [Book]
    book(id: ID!): Book
    searchBooks(query: String!): [Book]

    # Utilisateur
    me: User
    users: [User]  # Admin only

    # Commandes
    myOrders: [Order]
    order(id: ID!): Order
    allOrders: [Order]  # Admin only

    # Admin
    adminStats: AdminStats
}

type Mutation {
    # Authentification
    register(input: RegisterInput!): AuthPayload
    login(email: String!, password: String!): AuthPayload

    # Livres (Admin)
    createBook(input: BookInput!): Book
    updateBook(id: ID!, input: BookInput!): Book
    deleteBook(id: ID!): Boolean

    # Avis
    addReview(bookId: ID!, input: ReviewInput!): Book

    # Commandes
    createOrder(input: OrderInput!): Order
    cancelOrder(id: ID!): Order
}
\end{lstlisting}

\section{Comparaison REST vs GraphQL}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Critère} & \textbf{REST} & \textbf{GraphQL} \\
\hline
Flexibilité & Endpoints fixes & Requêtes flexibles \\
Over-fetching & Possible & Évité \\
Under-fetching & Possible & Évité \\
Versioning & Nécessaire & Non nécessaire \\
Caching & Simple (HTTP) & Plus complexe \\
Documentation & Swagger/OpenAPI & Schéma auto-documenté \\
\hline
\end{tabular}
\caption{Comparaison REST vs GraphQL}
\end{table}

% =============================================================================
% CHAPITRE 5 - SECURITE
% =============================================================================

\chapter{Sécurité}

\section{Authentification JWT}

\subsection{Génération du Token}

\begin{lstlisting}[language=JavaScript, caption={Génération de token JWT}]
const { generateToken } = require('../utils/helpers');

// Dans helpers.js
function generateToken(user) {
    return jwt.sign(
        { id: user._id, role: user.role },
        process.env.JWT_SECRET || 'secret',
        { expiresIn: '7d' }
    );
}
\end{lstlisting}

\subsection{Middleware d'Authentification}

\begin{lstlisting}[language=JavaScript, caption={Middleware auth.js}]
const { extractAndVerifyToken, ERRORS } = require('../utils/helpers');

function authMiddleware(req, res, next) {
    const authHeader = req.headers.authorization || req.headers.Authorization;
    const user = extractAndVerifyToken(authHeader);

    if (!user) {
        return res.status(401).json({ message: ERRORS.TOKEN_MISSING });
    }

    req.user = user;
    next();
}
\end{lstlisting}

\subsection{Protections JWT}

\begin{itemize}
    \item \textbf{Algorithm None Attack} : jwt.verify() exige une signature valide.
    \item \textbf{Payload Manipulation} : La signature détecte toute modification.
    \item \textbf{Token Expiration} : Durée de vie limitée (7 jours).
\end{itemize}

\section{Protection XSS}

\subsection{Module de Sanitization}

\begin{lstlisting}[language=JavaScript, caption={Configuration XSS (sanitize.js)}]
const xssOptions = {
    whiteList: {
        b: [], i: [], u: [], strong: [], em: [], br: [], p: []
    },
    stripIgnoreTag: true,
    stripIgnoreTagBody: ['script', 'style', 'noscript'],

    onTagAttr: function (tag, name, value) {
        // Bloquer tous les attributs on*
        if (name.toLowerCase().startsWith('on')) {
            return '';
        }
        // Bloquer javascript: dans href/src
        if ((name === 'href' || name === 'src') && value) {
            if (value.toLowerCase().startsWith('javascript:')) {
                return '';
            }
        }
    },

    onIgnoreTag: function (tag, html) {
        const dangerousTags = [
            'script', 'svg', 'iframe', 'object', 'embed'
        ];
        if (dangerousTags.includes(tag.toLowerCase())) {
            return '';
        }
    }
};
\end{lstlisting}

\subsection{Vecteurs XSS Bloqués}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Attaque} & \textbf{Protection} \\
\hline
\texttt{<script>alert('XSS')</script>} & Balise script supprimée \\
\texttt{<svg onload=alert('XSS')>} & SVG et onload bloqués \\
\texttt{<img onerror=alert('XSS')>} & Attributs on* supprimés \\
\texttt{<a href="javascript:...">} & URLs javascript: bloquées \\
\texttt{<body onload=...>} & Attribut onload supprimé \\
\hline
\end{tabular}
\caption{Vecteurs XSS et protections}
\end{table}

\section{Protection NoSQL Injection}

\begin{lstlisting}[language=JavaScript, caption={Protection contre NoSQL Injection}]
// Schema Mongoose avec typage strict
const userSchema = new mongoose.Schema({
    email: { type: String, required: true },  // Attend une STRING
    password: { type: String, required: true }
});

// bcrypt.compare() protege contre l'injection
userSchema.methods.comparePassword = async function(candidatePassword) {
    // Un objet {"$ne": ""} devient "[object Object]"
    // qui ne matchera jamais le hash
    return bcrypt.compare(candidatePassword, this.password);
};
\end{lstlisting}

\section{Autres Protections}

\begin{itemize}
    \item \textbf{Helmet} : Headers HTTP sécurisés.
    \item \textbf{CORS} : Configuration des origines autorisées.
    \item \textbf{Rate Limiting} : 1000 requêtes / 15 minutes.
    \item \textbf{Validation des entrées} : Mongoose schema validation.
\end{itemize}

% =============================================================================
% CHAPITRE 6 - MODULE HELPERS
% =============================================================================

\chapter{Module Utilitaire (helpers.js)}

\section{Objectif}

Le module \texttt{helpers.js} centralise les fonctions répétées dans le projet pour éliminer les redondances et faciliter la maintenance.

\section{Constantes d'Erreurs}

\begin{lstlisting}[language=JavaScript, caption={Constantes d'erreurs centralisées}]
const ERRORS = {
    // Authentification
    TOKEN_MISSING: 'Non autorise, token manquant',
    TOKEN_INVALID: 'Token invalide',
    ACCESS_DENIED: 'Acces refuse',
    ADMIN_REQUIRED: 'Acces refuse. Droits administrateur requis.',
    NOT_AUTHENTICATED: 'Non authentifie. Veuillez vous connecter.',

    // Ressources
    BOOK_NOT_FOUND: 'Livre introuvable',
    ORDER_NOT_FOUND: 'Commande introuvable',
    USER_NOT_FOUND: 'Utilisateur introuvable',
    PAYMENT_NOT_FOUND: 'Paiement introuvable',

    // Validation
    MISSING_FIELDS: 'Champs manquants',
    INVALID_CREDENTIALS: 'Identifiants invalides',
    EMAIL_EXISTS: 'Email deja utilise',

    // Commandes
    ORDER_CANNOT_MODIFY: 'Cette commande ne peut plus etre modifiee',
    ORDER_CANNOT_CANCEL: 'Cette commande ne peut plus etre annulee'
};
\end{lstlisting}

\section{Fonctions JWT}

\begin{lstlisting}[language=JavaScript, caption={Fonctions JWT centralisées}]
function generateToken(user) {
    return jwt.sign(
        { id: user._id, role: user.role },
        process.env.JWT_SECRET || 'secret',
        { expiresIn: '7d' }
    );
}

function extractAndVerifyToken(authHeader) {
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return null;
    }
    const token = authHeader.split(' ')[1];
    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET || 'secret');
        return { id: decoded.id, role: decoded.role };
    } catch (error) {
        return null;
    }
}
\end{lstlisting}

\section{Fonctions de Gestion des Stocks}

\begin{lstlisting}[language=JavaScript, caption={Gestion centralisée des stocks}]
async function checkStockAvailability(orderItems) {
    for (const item of orderItems) {
        const book = await Book.findById(item.product);
        if (!book || book.stock < item.qty) {
            return { success: false, error: `Stock insuffisant` };
        }
    }
    return { success: true };
}

async function decrementStock(orderItems) {
    for (const item of orderItems) {
        await Book.findByIdAndUpdate(item.product, {
            $inc: { stock: -item.qty }
        });
    }
}

async function incrementStock(orderItems) {
    for (const item of orderItems) {
        await Book.findByIdAndUpdate(item.product, {
            $inc: { stock: item.qty }
        });
    }
}
\end{lstlisting}

\section{Fonctions de Vérification}

\begin{lstlisting}[language=JavaScript, caption={Fonctions de vérification}]
function isOwnerOrAdmin(resourceUserId, currentUserId, userRole) {
    const isOwner = resourceUserId.toString() === currentUserId.toString();
    const isAdmin = userRole === 'admin';
    return isOwner || isAdmin;
}

function canModifyOrder(status) {
    const nonModifiableStatuses = ['shipped', 'delivered', 'cancelled'];
    return !nonModifiableStatuses.includes(status);
}

function canCancelOrder(status) {
    const nonCancellableStatuses = ['shipped', 'delivered', 'cancelled'];
    return !nonCancellableStatuses.includes(status);
}
\end{lstlisting}

% =============================================================================
% CHAPITRE 7 - TESTS DE SECURITE
% =============================================================================

\chapter{Tests de Sécurité}

\section{Présentation du Script de Test}

Un script Python complet (\texttt{security\_tests/test\_vulnerabilities.py}) a été développé pour tester automatiquement les vulnérabilités de l'API. Ce script teste 3 catégories principales de vulnérabilités du OWASP Top 10.

\subsection{Configuration}

\begin{lstlisting}[language=Python, caption={Configuration du script de test}]
# URL de base de l'API
BASE_URL = "http://localhost:5000"

# Credentials de test
TEST_EMAIL = "test@example.com"
TEST_PASSWORD = "password123"

# Compteurs de resultats
results = {
    "passed": 0,      # Tests reussis (attaque bloquee)
    "failed": 0,      # Tests echoues (vulnerabilite trouvee)
    "warnings": 0,    # Avertissements
    "total": 0
}
\end{lstlisting}

\subsection{Exécution}

\begin{lstlisting}[language=bash, caption={Exécution des tests}]
# Installation des dependances
cd security_tests
pip install -r requirements.txt

# Lancer les tests
python test_vulnerabilities.py
\end{lstlisting}

\section{Tests JWT (JSON Web Token)}

Les JWT sont composés de 3 parties : Header, Payload et Signature. Plusieurs attaques sont possibles sur les JWT mal implémentés.

\subsection{Test 1 : Algorithm None Attack}

\begin{lstlisting}[language=Python, caption={Test Algorithm None}]
def test_jwt_algorithm_none():
    """
    Tentative de bypass en definissant l'algorithme a 'none'
    """
    # Creer un header avec alg: none
    fake_header = base64.urlsafe_b64encode(
        json.dumps({"alg": "none", "typ": "JWT"}).encode()
    ).decode().rstrip('=')

    # Token sans signature
    none_token = f"{fake_header}.{payload}."

    response = requests.get(
        f"{BASE_URL}/api/orders/myorders",
        headers={"Authorization": f"Bearer {none_token}"}
    )

    # Doit retourner 401 (non autorise)
    assert response.status_code == 401
\end{lstlisting}

\textbf{Résultat :} \colorbox{green!20}{SÉCURISÉ} - Le serveur rejette les tokens avec alg=none.

\subsection{Test 2 : Payload Manipulation}

\begin{lstlisting}[language=Python, caption={Test Manipulation du Payload}]
def test_jwt_payload_manipulation():
    """
    Modification du payload pour changer le role en 'admin'
    """
    # Decoder et modifier le payload
    payload_decoded['role'] = 'admin'

    # Re-encoder avec la meme signature (invalide)
    manipulated_token = f"{header}.{fake_payload}.{signature}"

    response = requests.get(
        f"{BASE_URL}/api/admin/stats",
        headers={"Authorization": f"Bearer {manipulated_token}"}
    )

    # Doit retourner 401 ou 403
    assert response.status_code in [401, 403]
\end{lstlisting}

\textbf{Résultat :} \colorbox{green!20}{SÉCURISÉ} - La signature est vérifiée, le payload modifié est rejeté.

\subsection{Test 3 : Invalid Signature}

\begin{lstlisting}[language=Python, caption={Test Signature Invalide}]
def test_jwt_invalid_signature():
    """
    Token avec une signature aleatoire/invalide
    """
    fake_signature = base64.urlsafe_b64encode(
        b"fake_signature_12345"
    ).decode().rstrip('=')

    invalid_token = f"{header}.{payload}.{fake_signature}"

    response = requests.get(
        f"{BASE_URL}/api/orders/myorders",
        headers={"Authorization": f"Bearer {invalid_token}"}
    )

    assert response.status_code == 401
\end{lstlisting}

\textbf{Résultat :} \colorbox{green!20}{SÉCURISÉ} - Les signatures invalides sont rejetées.

\section{Tests NoSQL Injection}

Les injections NoSQL exploitent les opérateurs MongoDB comme \texttt{\$ne}, \texttt{\$gt}, \texttt{\$regex}, \texttt{\$where}.

\subsection{Test 1 : Login Bypass avec \$ne}

\begin{lstlisting}[language=Python, caption={Test Injection \$ne}]
def test_nosql_ne_injection():
    """
    Tentative de connexion avec {"$ne": ""} pour bypasser le password
    """
    payload = {
        "email": "test@example.com",
        "password": {"$ne": ""}  # Not equal to empty = true
    }

    response = requests.post(
        f"{BASE_URL}/api/auth/login",
        json=payload
    )

    # Doit retourner 400 (identifiants invalides)
    assert response.status_code == 400
\end{lstlisting}

\textbf{Résultat :} \colorbox{green!20}{SÉCURISÉ} - Mongoose valide les types, l'objet est rejeté.

\subsection{Test 2 : Login Bypass avec \$gt}

\begin{lstlisting}[language=Python, caption={Test Injection \$gt}]
def test_nosql_gt_injection():
    """
    Tentative avec {"$gt": ""} (greater than empty string)
    """
    payload = {
        "email": {"$gt": ""},    # Email > "" = n'importe quel email
        "password": {"$gt": ""}  # Password > "" = n'importe quel password
    }

    response = requests.post(
        f"{BASE_URL}/api/auth/login",
        json=payload
    )

    assert response.status_code == 400
\end{lstlisting}

\textbf{Résultat :} \colorbox{green!20}{SÉCURISÉ} - La validation des entrées bloque l'injection.

\subsection{Test 3 : Injection \$regex}

\begin{lstlisting}[language=Python, caption={Test Injection \$regex}]
def test_nosql_regex_injection():
    """
    Injection d'expression reguliere dans le login
    """
    payload = {
        "email": {"$regex": ".*"},  # Match n'importe quel email
        "password": "test_password"
    }

    response = requests.post(
        f"{BASE_URL}/api/auth/login",
        json=payload
    )

    assert response.status_code == 400
\end{lstlisting}

\textbf{Résultat :} \colorbox{green!20}{SÉCURISÉ} - Les regex sont bloqués par le typage Mongoose.

\subsection{Test 4 : Injection \$where (JavaScript)}

\begin{lstlisting}[language=Python, caption={Test Injection \$where}]
def test_nosql_where_injection():
    """
    Tentative d'execution de code JavaScript via $where
    """
    payload = {
        "email": "test@example.com",
        "password": "test_password",
        "$where": "sleep(5000)"  # Tente d'executer du JS
    }

    start_time = time.time()
    response = requests.post(
        f"{BASE_URL}/api/auth/login",
        json=payload,
        timeout=10
    )
    elapsed_time = time.time() - start_time

    # Si le serveur n'a pas dormi, l'injection est bloquee
    assert elapsed_time < 4
\end{lstlisting}

\textbf{Résultat :} \colorbox{green!20}{SÉCURISÉ} - \texttt{\$where} est ignoré par Mongoose.

\section{Tests XSS (Cross-Site Scripting)}

Les tests XSS vérifient que les entrées utilisateur sont correctement "sanitisées" avant stockage.

\subsection{Payloads Testés}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Nom} & \textbf{Payload} & \textbf{Description} \\
\hline
Script basique & \texttt{<script>alert('XSS')</script>} & Injection script classique \\
Event handler & \texttt{<img onerror=alert('XSS')>} & Via attribut événement \\
SVG onload & \texttt{<svg onload=alert('XSS')>} & Via balise SVG \\
Body onload & \texttt{<body onload=alert('XSS')>} & Via balise body \\
JavaScript URL & \texttt{javascript:alert('XSS')} & Protocole javascript: \\
Encoded script & \texttt{\&\#60;script\&\#62;...} & Encodage HTML \\
Unicode escape & \texttt{<script>\textbackslash u0061lert...</script>} & Échappement Unicode \\
Mixed case & \texttt{<ScRiPt>alert...</ScRiPt>} & Casse mixte bypass \\
\hline
\end{tabular}
\caption{Liste des payloads XSS testés}
\end{table}

\subsection{Test XSS dans la Création de Livre}

\begin{lstlisting}[language=Python, caption={Test XSS Stored}]
def test_xss_book_creation():
    """
    Injection de scripts dans les champs titre/description
    """
    xss_payloads = [
        "<script>alert('XSS')</script>",
        "<svg onload=alert('XSS')>",
        "<img onerror=alert('XSS')>",
        "<body onload=alert('XSS')>"
    ]

    for payload in xss_payloads:
        book_data = {
            "title": "Test Book",
            "author": payload,
            "price": 9.99,
            "category": "Test",
            "description": payload
        }

        response = requests.post(
            f"{BASE_URL}/api/books",
            json=book_data,
            headers={"Authorization": f"Bearer {token}"}
        )

        if response.status_code == 201:
            book = response.json()
            # Verifier que le payload est sanitize
            assert '<script>' not in book['author']
            assert 'onload' not in book['description'].lower()
            assert 'onerror' not in book['description'].lower()
\end{lstlisting}

\subsection{Résultats XSS}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Payload} & \textbf{Avant sanitization} & \textbf{Après sanitization} \\
\hline
\texttt{<script>alert(1)</script>} & Code exécuté & \texttt{(vide)} \\
\texttt{<svg onload=alert(1)>} & Code exécuté & \texttt{(vide)} \\
\texttt{<img onerror=alert(1)>} & Code exécuté & \texttt{\&lt;img\&gt;} \\
\texttt{<body onload=alert(1)>} & Code exécuté & \texttt{(vide)} \\
\texttt{javascript:alert(1)} & URL dangereuse & \texttt{alert(1)} \\
\hline
\end{tabular}
\caption{Transformation des payloads XSS par le module sanitize}
\end{table}

\textbf{Tous les tests XSS :} \colorbox{green!20}{SÉCURISÉS}

\section{Rapport Final des Tests}

\subsection{Synthèse des Résultats}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|l|}
\hline
\textbf{Catégorie} & \textbf{Tests} & \textbf{Sécurisés} & \textbf{Statut} \\
\hline
JWT - Algorithm None & 1 & 1 & \colorbox{green!20}{PASSÉ} \\
JWT - Payload Manipulation & 1 & 1 & \colorbox{green!20}{PASSÉ} \\
JWT - Invalid Signature & 1 & 1 & \colorbox{green!20}{PASSÉ} \\
JWT - Format Validation & 1 & 1 & \colorbox{green!20}{PASSÉ} \\
\hline
NoSQL - \$ne Injection & 1 & 1 & \colorbox{green!20}{PASSÉ} \\
NoSQL - \$gt Injection & 1 & 1 & \colorbox{green!20}{PASSÉ} \\
NoSQL - \$regex Injection & 1 & 1 & \colorbox{green!20}{PASSÉ} \\
NoSQL - \$where Injection & 1 & 1 & \colorbox{green!20}{PASSÉ} \\
NoSQL - Query Parameters & 1 & 1 & \colorbox{green!20}{PASSÉ} \\
\hline
XSS - Script basique & 1 & 1 & \colorbox{green!20}{PASSÉ} \\
XSS - Event handlers & 1 & 1 & \colorbox{green!20}{PASSÉ} \\
XSS - SVG onload & 1 & 1 & \colorbox{green!20}{PASSÉ} \\
XSS - Body onload & 1 & 1 & \colorbox{green!20}{PASSÉ} \\
XSS - JavaScript URL & 1 & 1 & \colorbox{green!20}{PASSÉ} \\
XSS - Encoded/Unicode & 1 & 1 & \colorbox{green!20}{PASSÉ} \\
XSS - Commentaires & 1 & 1 & \colorbox{green!20}{PASSÉ} \\
XSS - Reflected & 1 & 1 & \colorbox{green!20}{PASSÉ} \\
\hline
\textbf{TOTAL} & \textbf{17} & \textbf{17} & \colorbox{green!20}{\textbf{100\%}} \\
\hline
\end{tabular}
\caption{Synthèse complète des tests de sécurité}
\end{table}

\subsection{Sortie Console du Script}

\begin{lstlisting}[language=bash, caption={Exemple de sortie du script de test}]
======================================================================
         BIBLIO POCHE - TESTS DE SECURITE API
======================================================================

Date: 2025-01-15 14:30:00
Cible: http://localhost:5000
======================================================================
[OK] Serveur accessible

======================================================================
 TESTS JWT (JSON Web Token)
======================================================================

[INFO] Token valide obtenu: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

[TEST] JWT Algorithm None Attack
       Tentative de bypass en definissant l'algorithme a 'none'
[SECURISE] Algorithm None Attack bloquee

[TEST] JWT Payload Manipulation
       Modification du payload pour changer le role en 'admin'
[INFO] Payload original: {'id': '...', 'role': 'user', 'iat': ...}
[SECURISE] Manipulation du payload bloquee

[TEST] JWT Invalid Signature
       Token avec une signature aleatoire/invalide
[SECURISE] Signature invalide rejetee

======================================================================
 TESTS NoSQL INJECTION (MongoDB)
======================================================================

[TEST] NoSQL Injection - Login Bypass ($ne)
       Tentative avec {"$ne": ""} pour bypasser le password
[SECURISE] Injection $ne bloquee

[TEST] NoSQL Injection - Login Bypass ($gt)
       Tentative avec {"$gt": ""} (greater than empty)
[SECURISE] Injection $gt bloquee

[TEST] NoSQL Injection - $regex
       Injection d'expression reguliere dans le login
[SECURISE] Injection $regex bloquee

[TEST] NoSQL Injection - $where (JavaScript)
       Tentative d'execution de code JavaScript
[SECURISE] Injection $where bloquee

======================================================================
 TESTS XSS (Cross-Site Scripting)
======================================================================

[TEST] XSS Stored - Creation de livre
       Injection de scripts dans les champs titre/description

  Testing: Script basique
  Payload: <script>alert('XSS')</script>
  [SECURISE] Payload sanitize correctement

  Testing: SVG onload
  Payload: <svg onload=alert('XSS')>
  [SECURISE] Payload sanitize correctement

  Testing: Body onload
  Payload: <body onload=alert('XSS')>
  [SECURISE] Payload sanitize correctement

[TEST] XSS Stored - Avis/Commentaires
       Injection de scripts dans les commentaires
[SECURISE] Commentaire sanitize correctement

[TEST] XSS Reflected - Parametres de recherche
       Injection dans les parametres de requete
[SECURISE] Parametres de recherche securises

======================================================================
 RAPPORT FINAL
======================================================================

  Tests executes:  17
  Securises:       17
  Vulnerables:     0
  Avertissements:  0

  Taux de securite: 100.0%

  EXCELLENT! Aucune vulnerabilite detectee.

======================================================================
\end{lstlisting}

% =============================================================================
% CHAPITRE 8 - CHOIX TECHNIQUES ET DIFFICULTES
% =============================================================================

\chapter{Choix Techniques et Difficultés Rencontrées}

\section{Choix Techniques}

\subsection{Architecture Backend}

\subsubsection{Node.js et Express.js}

\textbf{Choix :} Node.js avec Express.js comme framework backend.

\textbf{Justification :}
\begin{itemize}
    \item \textbf{Performance} : Architecture non-bloquante et événementielle, idéale pour les API REST avec de nombreuses requêtes I/O.
    \item \textbf{Écosystème NPM} : Accès à des milliers de packages pour accélérer le développement.
    \item \textbf{JavaScript unifié} : Même langage côté serveur et client (React), facilitant le partage de code et la compréhension.
    \item \textbf{Simplicité} : Express.js offre une API minimaliste et flexible pour créer des routes rapidement.
\end{itemize}

\subsubsection{MongoDB avec Mongoose}

\textbf{Choix :} Base de données NoSQL MongoDB avec l'ODM Mongoose.

\textbf{Justification :}
\begin{itemize}
    \item \textbf{Flexibilité du schéma} : Les documents JSON s'adaptent facilement aux évolutions du modèle de données.
    \item \textbf{Performance} : Excellentes performances en lecture pour un catalogue de livres.
    \item \textbf{Scalabilité} : Sharding natif pour la mise à l'échelle horizontale.
    \item \textbf{Mongoose} : Validation des schémas, middleware, et protection implicite contre les injections NoSQL.
\end{itemize}

\begin{lstlisting}[language=JavaScript, caption={Exemple de schéma Mongoose avec validation}]
const bookSchema = new mongoose.Schema({
    title: {
        type: String,      // Typage strict = protection NoSQL
        required: true,
        trim: true
    },
    price: {
        type: Number,
        required: true,
        min: 0             // Validation metier
    },
    stock: {
        type: Number,
        default: 10,
        min: 0
    }
}, { timestamps: true });  // createdAt, updatedAt automatiques
\end{lstlisting}

\subsubsection{Double API : REST et GraphQL}

\textbf{Choix :} Implémenter les deux paradigmes d'API.

\textbf{Justification :}
\begin{itemize}
    \item \textbf{REST} : Standard industriel, simple à comprendre, caching HTTP natif, idéal pour les opérations CRUD simples.
    \item \textbf{GraphQL} : Flexibilité des requêtes, évite l'over-fetching, idéal pour le frontend React avec des besoins de données complexes.
    \item \textbf{Cas d'usage REST} : Opérations admin (pagination, filtres), webhooks, intégrations tierces.
    \item \textbf{Cas d'usage GraphQL} : Interface utilisateur (panier, détails produit avec avis), requêtes imbriquées.
\end{itemize}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Critère} & \textbf{REST} & \textbf{GraphQL} \\
\hline
Catalogue livres & GET /api/books & query \{ books \} \\
Détail + avis & 2 requêtes & 1 requête imbriquée \\
Admin stats & GET /api/admin/stats & query \{ adminStats \} \\
Caching & Simple (HTTP) & Complexe (Apollo) \\
\hline
\end{tabular}
\caption{Comparaison des usages REST vs GraphQL dans le projet}
\end{table}

\subsection{Sécurité}

\subsubsection{JWT pour l'Authentification}

\textbf{Choix :} JSON Web Tokens avec l'algorithme HS256.

\textbf{Justification :}
\begin{itemize}
    \item \textbf{Stateless} : Pas de session serveur, scalabilité horizontale facilitée.
    \item \textbf{Auto-contenu} : Le token contient les informations utilisateur (id, role).
    \item \textbf{Expiration} : Durée de vie limitée (7 jours) pour limiter l'impact d'un vol de token.
    \item \textbf{HS256} : Algorithme symétrique simple et sécurisé pour une application mono-serveur.
\end{itemize}

\subsubsection{Sanitization XSS Personnalisée}

\textbf{Choix :} Module de sanitization personnalisé basé sur la bibliothèque \texttt{xss}.

\textbf{Justification :}
\begin{itemize}
    \item \textbf{Configuration par défaut insuffisante} : La bibliothèque \texttt{xss} ne bloque pas tous les vecteurs (SVG, event handlers).
    \item \textbf{Whitelist stricte} : Seules les balises de formatage basiques sont autorisées.
    \item \textbf{Blocage des attributs on*} : Prévention des injections via événements JavaScript.
    \item \textbf{Filtrage des protocoles} : Blocage de \texttt{javascript:}, \texttt{data:}, \texttt{vbscript:}.
\end{itemize}

\subsection{Organisation du Code}

\subsubsection{Module Helpers Centralisé}

\textbf{Choix :} Création d'un module \texttt{utils/helpers.js} pour centraliser les fonctions répétées.

\textbf{Justification :}
\begin{itemize}
    \item \textbf{DRY (Don't Repeat Yourself)} : Élimination des redondances de code.
    \item \textbf{Maintenabilité} : Un seul endroit à modifier en cas de changement.
    \item \textbf{Cohérence} : Messages d'erreur uniformes dans toute l'application.
    \item \textbf{Testabilité} : Fonctions isolées faciles à tester unitairement.
\end{itemize}

\begin{lstlisting}[language=JavaScript, caption={Structure du module helpers.js}]
module.exports = {
    // Constantes centralisees
    ERRORS,
    ORDER_STATUSES,

    // JWT
    generateToken,
    extractAndVerifyToken,

    // Verification de propriete
    isOwnerOrAdmin,
    isOwner,

    // Gestion des stocks
    checkStockAvailability,
    decrementStock,
    incrementStock,

    // Validation des statuts
    canModifyOrder,
    canCancelOrder,
    isValidOrderStatus
};
\end{lstlisting}

\section{Difficultés Rencontrées et Solutions}

\subsection{Difficulté 1 : Incompatibilité Apollo Server v4 avec CommonJS}

\textbf{Problème :} L'installation initiale de \texttt{@apollo/server} (v4+) a provoqué une erreur car ce package est ESM-only (ECMAScript Modules), incompatible avec notre projet CommonJS.

\begin{lstlisting}[language=bash, caption={Erreur rencontrée}]
Error [ERR_PACKAGE_PATH_NOT_EXPORTED]:
Package subpath './dist/express4' is not defined by "exports"
\end{lstlisting}

\textbf{Cause :} Node.js v24 avec un projet en CommonJS (\texttt{require()}) ne peut pas importer un package ESM-only.

\textbf{Solution :} Migration vers \texttt{apollo-server-express@3.13.0} qui supporte CommonJS.

\begin{lstlisting}[language=JavaScript, caption={Avant (incompatible)}]
// @apollo/server v4 - ESM only
import { ApolloServer } from '@apollo/server';
import { expressMiddleware } from '@apollo/server/express4';
\end{lstlisting}

\begin{lstlisting}[language=JavaScript, caption={Après (compatible CommonJS)}]
// apollo-server-express v3 - CommonJS compatible
const { ApolloServer } = require('apollo-server-express');

const server = new ApolloServer({ typeDefs, resolvers, context });
await server.start();
server.applyMiddleware({ app, path: '/graphql' });
\end{lstlisting}

\textbf{Fichiers modifiés :}
\begin{itemize}
    \item \texttt{package.json} : Changement de dépendance.
    \item \texttt{graphql/index.js} : Nouvelle API Apollo Server.
    \item \texttt{graphql/schema.js} : Import de \texttt{gql} depuis apollo-server-express.
\end{itemize}

\subsection{Difficulté 2 : Vulnérabilités XSS Non Bloquées}

\textbf{Problème :} Les tests de sécurité ont révélé que la bibliothèque \texttt{xss} avec sa configuration par défaut ne bloquait pas certains vecteurs d'attaque :

\begin{itemize}
    \item \texttt{<svg onload=alert('XSS')>} - SVG avec event handler.
    \item \texttt{<body onload=alert('XSS')>} - Body avec event handler.
\end{itemize}

\begin{lstlisting}[language=bash, caption={Résultats des tests avant correction}]
Testing: SVG onload
Payload: <svg onload=alert('XSS')>
[VULNERABLE] Event handlers non sanitizes!

Testing: Body onload
Payload: <body onload=alert('XSS')>
[VULNERABLE] Event handlers non sanitizes!
\end{lstlisting}

\textbf{Cause :} La configuration par défaut de \texttt{xss()} n'inclut pas de whitelist stricte et ne bloque pas tous les attributs \texttt{on*}.

\textbf{Solution :} Création d'un module de sanitization personnalisé avec :
\begin{enumerate}
    \item Whitelist stricte de balises autorisées.
    \item Callback \texttt{onTagAttr} pour bloquer tous les attributs commençant par "on".
    \item Callback \texttt{onIgnoreTag} pour supprimer les balises dangereuses.
    \item Nettoyage supplémentaire avec expressions régulières.
\end{enumerate}

\begin{lstlisting}[language=JavaScript, caption={Solution implémentée dans sanitize.js}]
const xssOptions = {
    whiteList: {
        b: [], i: [], u: [], strong: [], em: [], br: [], p: []
    },
    stripIgnoreTag: true,
    stripIgnoreTagBody: ['script', 'style', 'noscript'],

    onTagAttr: function (tag, name, value) {
        // Bloquer TOUS les attributs on*
        if (name.toLowerCase().startsWith('on')) {
            return '';  // Supprimer l'attribut
        }
    },

    onIgnoreTag: function (tag, html) {
        const dangerousTags = ['script', 'svg', 'iframe', 'object',
                               'embed', 'body', 'form', 'input'];
        if (dangerousTags.includes(tag.toLowerCase())) {
            return '';  // Supprimer completement
        }
    }
};
\end{lstlisting}

\textbf{Résultat :} Tous les tests XSS passent après correction.

\subsection{Difficulté 3 : Redondance de Code entre REST et GraphQL}

\textbf{Problème :} Le code était dupliqué entre les routes REST et les resolvers GraphQL :
\begin{itemize}
    \item Génération de token JWT : 4 occurrences identiques.
    \item Vérification de propriété des ressources : 7 occurrences.
    \item Gestion des stocks (increment/decrement) : 6 occurrences.
    \item Messages d'erreur : 13+ occurrences avec variations.
\end{itemize}

\textbf{Impact :}
\begin{itemize}
    \item Risque d'incohérence lors des modifications.
    \item Difficulté de maintenance.
    \item Code plus volumineux et moins lisible.
\end{itemize}

\textbf{Solution :} Refactorisation avec le module \texttt{utils/helpers.js}.

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Fichier} & \textbf{Avant} & \textbf{Après} & \textbf{Réduction} \\
\hline
middleware/auth.js & 21 lignes & 16 lignes & -24\% \\
middleware/admin.js & 26 lignes & 20 lignes & -23\% \\
routes/orderRoutes.js & 157 lignes & 145 lignes & -8\% \\
routes/paymentRoutes.js & 213 lignes & 190 lignes & -11\% \\
graphql/resolvers.js & 483 lignes & 415 lignes & -14\% \\
\hline
\textbf{Total} & \textbf{900 lignes} & \textbf{786 lignes} & \textbf{-13\%} \\
\hline
\end{tabular}
\caption{Réduction de code après refactorisation}
\end{table}

\subsection{Difficulté 4 : Bug des Statistiques Admin avec 0 Commandes}

\textbf{Problème :} Le dashboard admin affichait des revenus même quand il y avait 0 commandes, ce qui était illogique et trompeur.

\begin{lstlisting}[language=JavaScript, caption={Code problématique}]
// Calculait les revenus meme sans commandes
const revenueResult = await Payment.aggregate([
    { $match: { status: 'completed' } },
    { $group: { _id: null, total: { $sum: '$amount' } } }
]);
totalRevenue = revenueResult[0]?.total || 0;
\end{lstlisting}

\textbf{Cause :} La requête d'agrégation sur les paiements retournait des valeurs résiduelles ou des données de test, indépendamment du nombre de commandes.

\textbf{Solution :} Ajout d'une condition pour ne calculer les revenus que s'il y a des commandes.

\begin{lstlisting}[language=JavaScript, caption={Solution implémentée}]
// Revenus totaux - SEULEMENT si il y a des commandes
let totalRevenue = 0;
if (totalOrders > 0) {
    const revenueResult = await Payment.aggregate([
        { $match: { status: { $in: ['completed', 'partially_refunded'] } } },
        { $group: {
            _id: null,
            total: { $sum: { $subtract: ['$amount', '$refundedAmount'] } }
        }}
    ]);
    totalRevenue = revenueResult[0]?.total || 0;
}

// Top livres - SEULEMENT si il y a des commandes
let topBooks = [];
if (totalOrders > 0) {
    topBooks = await Order.aggregate([...]);
}
\end{lstlisting}

\textbf{Fichiers modifiés :}
\begin{itemize}
    \item \texttt{routes/adminRoutes.js} : Route GET /api/admin/stats.
    \item \texttt{graphql/resolvers.js} : Query adminStats.
\end{itemize}

\subsection{Difficulté 5 : Gestion des Stocks lors des Annulations}

\textbf{Problème :} Les stocks n'étaient pas correctement remis lors de l'annulation des commandes, causant des incohérences d'inventaire.

\textbf{Scénarios problématiques :}
\begin{enumerate}
    \item Annulation par l'utilisateur.
    \item Annulation par l'admin.
    \item Suppression d'une commande par l'admin.
    \item Remboursement complet d'un paiement.
\end{enumerate}

\textbf{Solution :} Centralisation de la logique de gestion des stocks dans \texttt{helpers.js} et application systématique.

\begin{lstlisting}[language=JavaScript, caption={Fonctions de gestion des stocks}]
async function decrementStock(orderItems) {
    for (const item of orderItems) {
        await Book.findByIdAndUpdate(item.product, {
            $inc: { stock: -item.qty }
        });
    }
}

async function incrementStock(orderItems) {
    for (const item of orderItems) {
        await Book.findByIdAndUpdate(item.product, {
            $inc: { stock: item.qty }
        });
    }
}
\end{lstlisting}

\textbf{Application :}
\begin{itemize}
    \item \texttt{createOrder} : \texttt{decrementStock()}.
    \item \texttt{cancelOrder} : \texttt{incrementStock()}.
    \item \texttt{deleteOrder} (admin) : \texttt{incrementStock()} si statut != cancelled.
    \item \texttt{updateOrder} (admin, status=cancelled) : \texttt{incrementStock()}.
\end{itemize}

\section{Leçons Apprises}

\begin{enumerate}
    \item \textbf{Vérifier la compatibilité des modules} : Toujours vérifier si un package NPM est ESM ou CommonJS avant installation.

    \item \textbf{Ne pas faire confiance aux configurations par défaut} : Les bibliothèques de sécurité nécessitent souvent une configuration personnalisée.

    \item \textbf{Factoriser dès le début} : Identifier les patterns répétitifs tôt dans le développement pour éviter la dette technique.

    \item \textbf{Tester la sécurité en continu} : Les tests automatisés permettent de détecter les régressions de sécurité.

    \item \textbf{Documenter les décisions} : Garder une trace des choix techniques facilite la maintenance et l'onboarding.
\end{enumerate}

% =============================================================================
% CHAPITRE 9 - DOCUMENTATION API
% =============================================================================

\chapter{Documentation API}

\section{Swagger/OpenAPI}

La documentation OpenAPI 3.0 est disponible dans \texttt{backend/swagger.json} et couvre :

\begin{itemize}
    \item 45+ endpoints documentés.
    \item 11 schémas de données.
    \item Exemples de requêtes et réponses.
    \item Codes d'erreur et messages.
\end{itemize}

\section{Collection Postman}

Une collection Postman complète est fournie avec :

\begin{itemize}
    \item 35+ requêtes pré-configurées.
    \item Variables d'environnement.
    \item Tests automatisés.
    \item Scripts de pré-requête pour l'authentification.
\end{itemize}

\section{Utilisation de l'API}

\subsection{Authentification}

\begin{lstlisting}[language=bash, caption={Exemple d'authentification}]
# Inscription
curl -X POST http://localhost:5000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{"username":"test","email":"test@test.com","password":"123456"}'

# Connexion
curl -X POST http://localhost:5000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"123456"}'
\end{lstlisting}

\subsection{Requêtes Protégées}

\begin{lstlisting}[language=bash, caption={Utilisation du token}]
# Recuperer mes commandes
curl -X GET http://localhost:5000/api/orders/myorders \
  -H "Authorization: Bearer <votre_token>"
\end{lstlisting}

% =============================================================================
% CHAPITRE 10 - CONCLUSION
% =============================================================================

\chapter{Conclusion}

\section{Résumé}

Le projet Biblio Poche API fournit une solution backend complète et sécurisée pour une plateforme de vente de livres. Les points forts incluent :

\begin{itemize}
    \item Double interface REST et GraphQL.
    \item Sécurité renforcée (JWT, XSS, NoSQL Injection).
    \item Code factorisé et maintenable via le module helpers.js.
    \item Documentation complète (Swagger, Postman).
    \item Tests de sécurité automatisés.
\end{itemize}

\section{Améliorations Possibles}

\begin{itemize}
    \item Intégration d'un système de paiement réel (Stripe).
    \item Ajout de tests unitaires et d'intégration.
    \item Implémentation de WebSockets pour les notifications temps réel.
    \item Mise en cache avec Redis.
    \item Déploiement avec Docker et CI/CD.
\end{itemize}

% =============================================================================
% ANNEXES
% =============================================================================

\appendix

\chapter{Liste des Fichiers}

\begin{longtable}{|l|p{8cm}|}
\hline
\textbf{Fichier} & \textbf{Description} \\
\hline
\endhead

\multicolumn{2}{|c|}{\textbf{Backend - Configuration}} \\
\hline
server.js & Point d'entrée principal \\
package.json & Dépendances Node.js \\
\hline

\multicolumn{2}{|c|}{\textbf{Backend - Models}} \\
\hline
models/Book.js & Schema des livres \\
models/User.js & Schema des utilisateurs \\
models/Order.js & Schema des commandes \\
models/Payment.js & Schema des paiements \\
\hline

\multicolumn{2}{|c|}{\textbf{Backend - Routes REST}} \\
\hline
routes/authRoutes.js & Authentification \\
routes/bookRoutes.js & Gestion des livres \\
routes/orderRoutes.js & Gestion des commandes \\
routes/paymentRoutes.js & Gestion des paiements \\
routes/adminRoutes.js & Administration \\
\hline

\multicolumn{2}{|c|}{\textbf{Backend - GraphQL}} \\
\hline
graphql/index.js & Configuration Apollo Server \\
graphql/schema.js & Types GraphQL \\
graphql/resolvers.js & Resolvers GraphQL \\
\hline

\multicolumn{2}{|c|}{\textbf{Backend - Middleware}} \\
\hline
middleware/auth.js & Authentification JWT \\
middleware/admin.js & Vérification admin \\
\hline

\multicolumn{2}{|c|}{\textbf{Backend - Utilitaires}} \\
\hline
utils/sanitize.js & Protection XSS \\
utils/helpers.js & Fonctions partagées \\
\hline

\multicolumn{2}{|c|}{\textbf{Documentation}} \\
\hline
swagger.json & Documentation OpenAPI \\
README.md & Documentation projet \\
API\_DOCUMENTATION.md & Guide API \\
SECURITY\_PROTECTIONS.md & Documentation sécurité \\
\hline

\multicolumn{2}{|c|}{\textbf{Tests}} \\
\hline
security\_tests/test\_vulnerabilities.py & Tests de sécurité \\
postman/*.json & Collection Postman \\
\hline

\end{longtable}

% =============================================================================
% FIN DU DOCUMENT
% =============================================================================

\end{document}